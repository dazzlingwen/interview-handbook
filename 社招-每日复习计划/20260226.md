# 原型链与继承

知识点复习链接：
https://fe.ecool.fun/knowledge-learn

## 八股

1. 什么是原型？什么是原型链？（原型链查找机制）

原型===prototype。

而prototype是构造函数的一个属性（箭头函数没有）。

```
function Person() {}

Person.prototype
```

它是一个对象，用来：

👉 存放所有实例共享的属性和方法。

```
Person.prototype.sayHi = function() {
  console.log("Hi");
};
```

此时：
```
let p = new Person();
p.sayHi()； // 可以调用Person的方法，输出Hi
```

2. ES6 class 本质



3. constructor 是什么？可以被修改吗？

4. instanceof 的原理是什么？
5. new 操作符做了什么？
6. JS 有哪些继承方式？
   1. 原型链继承

    缺点：引用类型共享

    2. 借用构造函数继承

    缺点：方法不能复用

    3. 组合继承

    优点：解决共享问题
    缺点：调用两次父构造函数

    4. 寄生组合继承（最优 ES5 方案）

7. 原型链污染是什么？避免原型链污染的方式有哪些？

        Object.create(null)

8. class A extends B 底层发生了什么？
9. Babel 如何编译 class？
10. prototype 和 proto 有什么区别？

        **proto是实例对象的属性，指向实例原型的prototype属性。**

        - 函数既是函数也是对象

        - 所有函数的 proto 都指向 Function.prototype

        - 普通对象没有 prototype



## 手写题

1. 手写instanceof

2. 手写new，包括使用方式

3. 手写Object.create()

4. 寄生组合继承


-------------

# 🔥 第一套：大厂难度 · 连环追问压迫版

## 第一题：instanceof 到底可靠吗？

> 你说 instanceof 是沿原型链查找，那我重写 prototype 会怎么样？

```js
function A() {}
const a = new A()

A.prototype = {}
```

### 追问 1：

`a instanceof A` 结果是什么？

👉 false

因为 instanceof 判断的是 **当前 A.prototype 是否在 a 的原型链上**。

---

### 追问 2：

那 constructor 还能判断类型吗？

👉 不可靠。

因为：

```js
A.prototype = {}
```

constructor 已经丢失。

---

### 追问 3：

那 instanceof 可靠吗？

也不完全可靠：

* 跨 iframe
* Symbol.hasInstance 可被重写
* 原型被篡改

---

### 追问 4：

最可靠的类型判断方式？

```js
Object.prototype.toString.call(obj)
```

或者：

```js
Array.isArray()
```

如果能提到：

* Symbol.toStringTag
* Symbol.hasInstance

基本已经拉开档次。

---

## 第二题：class 继承底层到底干了什么？

```js
class A {}
class B extends A {}
```

### 追问 1：

B 的原型链结构画出来。

必须说清楚两条链：

1. 实例链
2. 构造函数链

结构：

```
实例.__proto__ === B.prototype
B.prototype.__proto__ === A.prototype

B.__proto__ === A
A.__proto__ === Function.prototype
```

---

### 追问 2：

为什么必须先 super() 才能用 this？

正确回答：

* 子类实例对象必须由父类构造初始化
* ES6 class 内部使用的是 “先构建 this，再绑定”

---

### 追问 3：

class 为什么方法不可枚举？

因为：

* 方法定义在 prototype 上
* 使用 Object.defineProperty
* enumerable: false

---

## 第三题：解释这个现象

```js
Function.__proto__ === Function.prototype
```

这题是终极压轴。

正确理解：

* Function 是函数
* 函数由 Function 构造
* Function 自举
* 这是语言初始化阶段构建的闭环

如果你能说出：

> JS 引擎启动时会构建内建对象图，Function 是 bootstrap 的核心

基本已经是高级。

---

# 🔬 第二套：V8 底层机制 · 原型链

---

## 第一题：原型链查找真的是 O(n) 吗？

理论上：

* 是线性向上查找

但 V8 不会真的每次都走链。

---

### 深水区：

V8 用了什么优化？

👉 Hidden Class（隐藏类）
👉 Inline Cache（内联缓存）

---

## Hidden Class（隐藏类）

V8 会为对象创建内部结构描述：

```
{ x:1, y:2 }
```

有一个 shape 描述对象结构。

如果对象结构一致：

* 共享隐藏类
* 访问速度接近静态语言

---

## 追问：

如果动态给对象加属性会怎样？

```js
obj.z = 3
```

会触发：

* 隐藏类迁移（shape transition）
* 可能导致去优化

---

## 第二题：为什么频繁改 prototype 性能差？

因为：

* 原型链结构变化
* Inline Cache 失效
* 触发 deopt

---

## 第三题：删除属性为什么慢？

```js
delete obj.x
```

会导致：

* hidden class 退化
* 变成 dictionary mode

---

# ⚡ 第三套：V8 + 性能优化实战题

---

## 场景 1：构造函数里写方法 vs prototype 上写方法

```js
function A() {
  this.say = function() {}
}
```

vs

```js
A.prototype.say = function() {}
```

区别？

---

### 深度回答：

第一种：

* 每个实例都有独立函数
* 占内存
* 隐藏类不同

第二种：

* 方法共享
* 内存节省
* shape 稳定

---

## 场景 2：对象字面量 vs Object.create(null)

什么时候用？

* 做纯 map → Object.create(null)
* 做普通对象 → 字面量

---

## 场景 3：大量对象创建如何优化？

回答方向：

* 保持属性初始化顺序一致
* 构造函数中一次性声明所有字段
* 避免动态增删属性
* 避免 delete
* 避免频繁修改 prototype

---

## 场景 4：为什么 React 不推荐继承？

高级回答：

* 原型继承强耦合
* 组合更利于隐藏类稳定
* 组合更利于优化路径固定

---

# 真 · 大厂级总结

如果面试官问：

> 你理解的原型链，在引擎层面意味着什么？

高级回答框架：

1. JS 是基于对象委托
2. 属性查找沿 prototype chain
3. V8 用 Hidden Class + IC 优化访问
4. 结构稳定比继承技巧更重要
5. 性能关键在 shape 稳定性

---

# 终极判断标准

如果你能流畅讲清：

* 两条原型链（实例链 + 构造函数链）
* instanceof 可被篡改
* class 本质
* Hidden Class
* Inline Cache
* deopt 场景

那这块已经是 **强高级水平**。

---

如果你愿意，我可以：

* 给你一套【Google / 字节 面试风格真实压迫模拟】
* 或者一套【源码级：Babel 如何编译 class】
* 或者一套【结合工程实践的架构设计题】

你想继续往哪个维度打？
